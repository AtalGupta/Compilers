# FluxScript Bytecode Documentation

This document describes the bytecode operations and structure used by the FluxScript Virtual Machine (VM). The bytecode is generated by the `BytecodeCompiler` and executed by the `BytecodeVM`. Each operation is represented by an opcode and optional arguments, which the VM interprets to perform computations, manage data structures, and control program flow.

## Overview

The FluxScript VM is a stack-based virtual machine designed to execute bytecode instructions generated from a source program. The VM maintains:

- **Stack**: For operands and intermediate results.
- **Constants Table**: Stores literals (integers, floats, strings, function data, etc.).
- **Frames**: Manage function calls and local variables, supporting closures.
- **Instruction Set**: A sequence of opcodes with arguments that dictate VM behavior.

The `BytecodeCompiler` transforms an Abstract Syntax Tree (AST) into a sequence of instructions and a constants table. The `BytecodeVM` executes these instructions, handling operations like arithmetic, control flow, function calls, and data structure manipulation.

## Bytecode Structure

Each instruction is a tuple of the form `(opcode, *args)`, where:
- `opcode` is an integer identifying the operation.
- `*args` are zero or more arguments specific to the opcode (e.g., constant indices, variable names, or jump targets).

The constants table is a list of values (literals, function data, etc.) referenced by instructions via indices.

## Opcodes

Below is a comprehensive list of opcodes, grouped by category, along with their descriptions, stack effects, and arguments.

### Constants and Literals

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `LOAD_CONST` | 1 | Loads a constant from the constants table onto the stack. | Pushes: constant value | Index into constants table |
| `LOAD_TRUE` | 2 | Loads `True` onto the stack. | Pushes: `True` | None |
| `LOAD_FALSE` | 3 | Loads `False` onto the stack. | Pushes: `False` | None |

### Variables

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `LOAD_VAR` | 10 | Loads a variable's value onto the stack. | Pushes: variable value | Variable name (string) |
| `STORE_VAR` | 11 | Stores the top stack value into a variable and pushes it back. | Pops: value; Pushes: value | Variable name (string) |
| `REASSIGN_VAR` | 12 | Reassigns a value to an existing variable and pushes it back. | Pops: value; Pushes: value | Variable name (string) |

### Arithmetic Operations

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `ADD` | 20 | Adds the top two stack values. | Pops: right, left; Pushes: left + right | None |
| `SUBTRACT` | 21 | Subtracts the top value from the second-top value. | Pops: right, left; Pushes: left - right | None |
| `MULTIPLY` | 22 | Multiplies the top two stack values. | Pops: right, left; Pushes: left * right | None |
| `DIVIDE` | 23 | Divides the second-top value by the top value. | Pops: right, left; Pushes: left / right | None |
| `EXPONENT` | 24 | Raises the second-top value to the power of the top value. | Pops: right, left; Pushes: left ** right | None |
| `MODULO` | 25 | Computes the remainder of the second-top value divided by the top value. | Pops: right, left; Pushes: left % right | None |
| `NEGATE` | 26 | Negates the top stack value. | Pops: value; Pushes: -value | None |

### Comparison Operations

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `EQUAL` | 30 | Checks if the top two values are equal. | Pops: right, left; Pushes: left == right | None |
| `NOT_EQUAL` | 31 | Checks if the top two values are not equal. | Pops: right, left; Pushes: left != right | None |
| `LESS_THAN` | 32 | Checks if the second-top value is less than the top value. | Pops: right, left; Pushes: left < right | None |
| `GREATER_THAN` | 33 | Checks if the second-top value is greater than the top value. | Pops: right, left; Pushes: left > right | None |
| `LESS_EQUAL` | 34 | Checks if the second-top value is less than or equal to the top value. | Pops: right, left; Pushes: left <= right | None |
| `GREATER_EQUAL` | 35 | Checks if the second-top value is greater than or equal to the top value. | Pops: right, left; Pushes: left >= right | None |

### Logical Operations

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `AND` | 40 | Performs logical AND on the top two values. | Pops: right, left; Pushes: left and right | None |
| `OR` | 41 | Performs logical OR on the top two values. | Pops: right, left; Pushes: left or right | None |
| `NOT` | 42 | Performs logical NOT on the top value. | Pops: value; Pushes: not value | None |

### Control Flow

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `JUMP` | 50 | Jumps unconditionally to the specified instruction. | None | Instruction index |
| `JUMP_IF_FALSE` | 51 | Jumps to the specified instruction if the top value is false. | Pops: condition | Instruction index |
| `JUMP_IF_TRUE` | 52 | Jumps to the specified instruction if the top value is true. | Pops: condition | Instruction index |

### Functions

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `DEFINE_FUNC` | 60 | Defines a function and stores it in the current scope. | None | Function name (string), constant index (function data) |
| `CALL_FUNC` | 61 | Calls a function with the specified number of arguments. | Pops: function, args; Pushes: result | Number of arguments |
| `RETURN` | 62 | Returns from a function with the top stack value. | Pops: value; Pushes: value (to parent frame) | None |
| `LOAD_LAMBDA` | 63 | Loads a lambda function (closure) onto the stack. | Pushes: closure | Constant index (function data) |
| `DICT_FUNC_CALL` | 64 | Calls a function stored in a dictionary. | Pops: dict, key, args; Pushes: result | Number of arguments |

### Data Structures

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `BUILD_ARRAY` | 70 | Builds an array from the top N stack elements. | Pops: N elements; Pushes: array | Number of elements |
| `BUILD_DICT` | 71 | Builds a dictionary from N key-value pairs on the stack. | Pops: N pairs (key, value); Pushes: dict | Number of pairs |
| `ARRAY_ACCESS` | 72 | Accesses an element in an array or dictionary. | Pops: index, array/dict; Pushes: element | None |
| `ARRAY_ASSIGN` | 73 | Assigns a value to an array or dictionary element. | Pops: value, index, array/dict; Pushes: value | None |
| `GET_SIZE` | 74 | Gets the size of a string, array, or dictionary. | Pops: collection; Pushes: size | None |
| `MULTI_DIM_ACCESS` | 75 | Accesses a multi-dimensional array element. | Pops: N indices, array; Pushes: element | Number of indices |
| `MULTI_DIM_ASSIGN` | 76 | Assigns a value to a multi-dimensional array element. | Pops: value, N indices, array; Pushes: value | Number of indices |

### I/O Operations

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `PRINT` | 80 | Prints the top stack value. | Pops: value | None |

### Miscellaneous

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `POP` | 90 | Pops and discards the top stack value. | Pops: value | None |
| `DUP` | 91 | Duplicates the top stack value. | Pushes: top value | None |

### Program Termination

| Opcode | Value | Description | Stack Effect | Arguments |
|--------|-------|-------------|--------------|-----------|
| `HALT` | 99 | Halts execution. | None | None |

## Execution Model

The `BytecodeVM` operates as follows:

1. **Initialization**: Creates a global frame and initializes built-in functions (`to_string`, `to_number`, `split`, `substring`, `__append`, `size`, `word`).
2. **Frame Management**: Each function call creates a new `Frame` with its own stack, local variables, and closure environment. Frames are linked to parent frames for variable lookup.
3. **Instruction Execution**: The VM processes instructions sequentially, updating the instruction pointer (`ip`), stack, and variables. Jumps modify the `ip` for control flow.
4. **Closures**: Functions and lambdas capture their environment, allowing access to variables from outer scopes. The `Closure` class manages function code, parameters, constants, and environment.
5. **Error Handling**: The VM raises exceptions for invalid operations, undefined variables, division by zero, etc., stopping execution and reporting errors.

## Built-in Functions

The VM includes the following built-in functions, accessible in the global scope:

- `to_string(value)`: Converts a value to a string.
- `to_number(value)`: Converts a string to an integer or float.
- `split(string, delimiter)`: Splits a string by a delimiter into an array.
- `substring(string, start, [end])`: Extracts a substring from `start` to `end` (or end of string).
- `__append(array, value)`: Appends a value to an array (internal use).
- `size(collection)`: Returns the length of a string, array, or dictionary.
- `word(number)`: Converts an integer (1–1000) to its English word representation (e.g., 42 → "fortytwo").

## Example

Consider the AST for `2 + 3`:

```python
from AST.ast_1 import Integer, BinOp, Token
ast = BinOp(Integer(2), Token('PLUS', '+', 0, 0), Integer(3))
```

The `BytecodeCompiler` generates:

- **Constants**: `[2, 3]`
- **Instructions**:
  ```
  [(LOAD_CONST, 0),  # Load 2
   (LOAD_CONST, 1),  # Load 3
   (ADD,),           # Add them
   (HALT,)]          # Stop
  ```

The `BytecodeVM` executes this to produce `5`.

## Debugging

Set `debug=True` in the `BytecodeVM` constructor to print:

- Current instruction pointer (`ip`).
- Executed opcode name.
- Stack contents.
- Local variables and closure environment (if applicable).

This aids in tracing execution and diagnosing issues.

## Notes

- **Variable Scope**: Variables are looked up in the current frame's locals, then the closure environment, and finally parent frames.
- **Closures**: Functions and lambdas capture their environment, ensuring proper variable access in nested scopes.
- **Data Structures**: Arrays and dictionaries support dynamic creation and access, with multi-dimensional array operations for nested structures.
- **Error Handling**: The VM provides detailed error messages for common issues, such as undefined variables or invalid operations.
- **Extensibility**: New opcodes or built-in functions can be added by extending the `opcodes` module and `BytecodeVM`’s `_add_builtins` method.

This bytecode design balances simplicity and functionality, supporting a wide range of programming constructs while maintaining efficient execution.