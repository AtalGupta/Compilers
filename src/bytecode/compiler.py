"""
FluxScript Bytecode Compiler Module

This module implements the BytecodeCompiler class, which traverses the FluxScript AST and generates bytecode instructions for the FluxScript virtual machine. The compiler uses the Visitor pattern to handle each AST node type and emit the appropriate bytecode.

Features:
- Compiles expressions, statements, functions, arrays, dictionaries, and control flow
- Manages constants table and variable names
- Supports closures and lambda functions
- Handles break/continue for loops

Usage:
    compiler = BytecodeCompiler()
    instructions, constants = compiler.compile(ast)
    # Pass instructions and constants to the VM for execution
"""

from src.AST.ast_1 import *
from .opcodes import *

class BytecodeCompiler(Visitor):
    """
    Compiles FluxScript AST nodes into bytecode instructions for the VM.
    Implements the Visitor pattern for AST traversal.
    
    Attributes:
        instructions: List of generated bytecode instructions
        constants: Table of constants used in the program
        var_names: Mapping of variable names to indices
        var_count: Number of variables
        labels: Stack for jump labels
        break_stack: Stack for break statement jump locations
        continue_stack: Stack for continue statement jump locations
    """
    def __init__(self):
        self.instructions = []  # List of (opcode, *args)
        self.constants = []     # Constants table
        self.var_names = {}     # Variable name to index
        self.var_count = 0
        self.labels = []        # For jumps
        self.break_stack = []   # For break/continue
        self.continue_stack = []

    def compile(self, node):
        """
        Compile an AST node into bytecode instructions and constants.
        Args:
            node: The root AST node to compile
        Returns:
            Tuple of (instructions, constants)
        """
        self.instructions = []
        self.constants = []
        self.var_names = {}
        self.var_count = 0
        self.labels = []
        self.break_stack = []
        self.continue_stack = []
        node.accept(self)
        self.instructions.append((HALT,))
        return self.instructions, self.constants

    def add_const(self, value):
        """
        Add a constant to the constants table if not already present.
        Returns the index of the constant.
        """
        if value in self.constants:
            return self.constants.index(value)
        self.constants.append(value)
        return len(self.constants) - 1

    def visit_integer(self, node):
        """Emit bytecode for an integer literal."""
        idx = self.add_const(node.value)
        self.instructions.append((LOAD_CONST, idx))

    def visit_float(self, node):
        """Emit bytecode for a float literal."""
        idx = self.add_const(node.value)
        self.instructions.append((LOAD_CONST, idx))

    def visit_string(self, node):
        """Emit bytecode for a string literal."""
        idx = self.add_const(node.value)
        self.instructions.append((LOAD_CONST, idx))

    def visit_boolean(self, node):
        """Emit bytecode for a boolean literal."""
        self.instructions.append((LOAD_TRUE if node.value else LOAD_FALSE,))

    def visit_var(self, node):
        """Emit bytecode to load a variable's value."""
        self.instructions.append((LOAD_VAR, node.name))

    def visit_var_assign(self, node):
        """Emit bytecode for variable declaration and assignment."""
        node.value.accept(self)
        # Push the value back onto the stack after storing
        self.instructions.append((DUP,))  # Duplicate the value
        self.instructions.append((STORE_VAR, node.name))

    def visit_var_reassign(self, node):
        """Emit bytecode for variable reassignment."""
        node.value.accept(self)
        # No need for DUP here, since REASSIGN_VAR now pushes the value back onto the stack
        self.instructions.append((REASSIGN_VAR, node.name))

    def visit_bin_op(self, node):
        """Emit bytecode for a binary operation (e.g., +, -, *, /, etc.)."""
        node.left.accept(self)
        node.right.accept(self)
        op = node.operator.value
        if op == '+':
            self.instructions.append((ADD,))
        elif op == '-':
            self.instructions.append((SUBTRACT,))
        elif op == '*':
            self.instructions.append((MULTIPLY,))
        elif op == '/':
            self.instructions.append((DIVIDE,))
        elif op == '**':
            self.instructions.append((EXPONENT,))
        elif op == '%':
            self.instructions.append((MODULO,))
        elif op == '==':
            self.instructions.append((EQUAL,))
        elif op == '!=':
            self.instructions.append((NOT_EQUAL,))
        elif op == '<':
            self.instructions.append((LESS_THAN,))
        elif op == '>':
            self.instructions.append((GREATER_THAN,))
        elif op == '<=':
            self.instructions.append((LESS_EQUAL,))
        elif op == '>=':
            self.instructions.append((GREATER_EQUAL,))
        elif op == 'and':
            self.instructions.append((AND,))
        elif op == 'or':
            self.instructions.append((OR,))
        else:
            raise Exception(f"Unknown binary operator: {op}")

    def visit_unary_op(self, node):
        """Emit bytecode for a unary operation (e.g., -, not)."""
        node.right.accept(self)
        op = node.operator.value
        if op == '-':
            self.instructions.append((NEGATE,))
        elif op == 'not':
            self.instructions.append((NOT,))
        else:
            raise Exception(f"Unknown unary operator: {op}")

    def visit_lambda(self, node):
        """Emit bytecode for a lambda (anonymous function) definition."""
        # Create a new compiler instance for the lambda body
        compiler = BytecodeCompiler()
        
        # Compile the lambda body separately
        body_instructions, body_constants = compiler.compile(node.body)
        
        # Add RETURN instruction if not present (to ensure lambda always returns a value)
        if not body_instructions or body_instructions[-1][0] != RETURN:
            # If the last instruction isn't a return, add one that returns the top of the stack
            if body_instructions and body_instructions[-1][0] != HALT:
                # There are instructions, but the last one is not a return - add DUP and RETURN
                body_instructions.append((DUP,))
                body_instructions.append((RETURN,))
            else:
                # Empty body or just HALT - return None
                body_instructions.append((LOAD_CONST, compiler.add_const(None)))
                body_instructions.append((RETURN,))
        
        # Store lambda data as a constant
        idx = self.add_const({
            'name': 'lambda',  # Anonymous function
            'params': node.params,
            'code': body_instructions,
            'consts': body_constants,
            'free_vars': []  # Will be captured from the closure's env at runtime
        })
        
        # Create a closure for this lambda
        self.instructions.append((LOAD_LAMBDA, idx))

    def visit_block(self, node):
        """Emit bytecode for a block of statements."""
        for stmt in node.statements:
            stmt.accept(self)

    def visit_if(self, node):
        """Emit bytecode for an if-else statement."""
        node.condition.accept(self)
        jmp_false_idx = len(self.instructions)
        self.instructions.append((JUMP_IF_FALSE, None))
        node.then_branch.accept(self)
        if node.else_branch:
            jmp_end_idx = len(self.instructions)
            self.instructions.append((JUMP, None))
            self.instructions[jmp_false_idx] = (JUMP_IF_FALSE, len(self.instructions))
            node.else_branch.accept(self)
            self.instructions[jmp_end_idx] = (JUMP, len(self.instructions))
        else:
            self.instructions[jmp_false_idx] = (JUMP_IF_FALSE, len(self.instructions))

    def visit_while(self, node):
        """Emit bytecode for a while loop."""
        start_idx = len(self.instructions)
        node.condition.accept(self)
        jmp_false_idx = len(self.instructions)
        self.instructions.append((JUMP_IF_FALSE, None))
        self.continue_stack.append(start_idx)
        self.break_stack.append([])
        node.body.accept(self)
        self.instructions.append((JUMP, start_idx))
        self.instructions[jmp_false_idx] = (JUMP_IF_FALSE, len(self.instructions))
        for idx in self.break_stack.pop():
            self.instructions[idx] = (JUMP, len(self.instructions))
        self.continue_stack.pop()

    def visit_for(self, node):
        """Emit bytecode for a for loop."""
        # for (let i = start to end step step) { body }
        node.start.accept(self)
        self.instructions.append((STORE_VAR, node.variable))
        start_idx = len(self.instructions)
        self.instructions.append((LOAD_VAR, node.variable))
        node.end.accept(self)
        self.instructions.append((GREATER_THAN,))
        jmp_false_idx = len(self.instructions)
        self.instructions.append((JUMP_IF_TRUE, None))
        self.continue_stack.append(start_idx)
        self.break_stack.append([])
        node.body.accept(self)
        self.instructions.append((LOAD_VAR, node.variable))
        if node.step:
            node.step.accept(self)
        else:
            self.instructions.append((LOAD_CONST, self.add_const(1)))
        self.instructions.append((ADD,))
        self.instructions.append((STORE_VAR, node.variable))
        self.instructions.append((JUMP, start_idx))
        self.instructions[jmp_false_idx] = (JUMP_IF_TRUE, len(self.instructions))
        for idx in self.break_stack.pop():
            self.instructions[idx] = (JUMP, len(self.instructions))
        self.continue_stack.pop()

    def visit_break(self, node):
        """Emit bytecode for a break statement in a loop."""
        self.break_stack[-1].append(len(self.instructions))
        self.instructions.append((JUMP, None))

    def visit_continue(self, node):
        """Emit bytecode for a continue statement in a loop."""
        self.instructions.append((JUMP, self.continue_stack[-1]))

    def visit_func_def(self, node):
        """Emit bytecode for a function definition."""
        # Create a new compiler instance for the function body
        compiler = BytecodeCompiler()
        
        # Compile the function body separately
        body_instructions, body_constants = compiler.compile(node.body)
        
        # Store function data as a constant
        idx = self.add_const({
            'name': node.name,
            'params': node.params,
            'code': body_instructions,
            'consts': body_constants,
            'free_vars': node.free_vars or []
        })
        
        # Add instruction to define the function
        self.instructions.append((DEFINE_FUNC, node.name, idx))

    def visit_func_call(self, node):
        """Emit bytecode for a function call."""
        # Check if this is a dictionary access function call (e.g., dict["key"]())
        if isinstance(node.callee, ArrayAccess):
            # First put the dictionary on the stack
            node.callee.array.accept(self)
            
            # Then put the key on the stack
            node.callee.index.accept(self)
            
            # Push all arguments first
            for arg in node.args:
                arg.accept(self)
                
            # Special opcode for dictionary function call with number of arguments
            self.instructions.append((DICT_FUNC_CALL, len(node.args)))
        else:
            # Standard function call
            # First put the function reference on the stack
            node.callee.accept(self)
            
            # Then push all arguments onto the stack in order
            for arg in node.args:
                arg.accept(self)
                
            # Finally call the function with the number of arguments
            self.instructions.append((CALL_FUNC, len(node.args)))

    def visit_return(self, node):
        """Emit bytecode for a return statement."""
        node.value.accept(self)
        self.instructions.append((RETURN,))

    def visit_array(self, node):
        """Emit bytecode for an array literal."""
        for elem in node.elements:
            elem.accept(self)
        self.instructions.append((BUILD_ARRAY, len(node.elements)))

    def visit_dict(self, node):
        """Emit bytecode for a dictionary literal."""
        for key, value in node.pairs:
            key.accept(self)
            
            # If the value is a lambda function, we need special handling to ensure proper closure capture
            if isinstance(value, Lambda):
                # Create a new compiler instance for the lambda body
                lambda_compiler = BytecodeCompiler()
                
                # Compile the lambda body separately
                body_instructions, body_constants = lambda_compiler.compile(value.body)
                
                # Add RETURN instruction if not present
                if not body_instructions or body_instructions[-1][0] != RETURN:
                    if body_instructions and body_instructions[-1][0] != HALT:
                        body_instructions.append((DUP,))
                        body_instructions.append((RETURN,))
                    else:
                        body_instructions.append((LOAD_CONST, lambda_compiler.add_const(None)))
                        body_instructions.append((RETURN,))
                
                # Store lambda data as a constant
                idx = self.add_const({
                    'name': 'lambda',  # Anonymous function
                    'params': value.params,
                    'code': body_instructions,
                    'consts': body_constants,
                    'free_vars': []  # Will be captured from the closure's env at runtime
                })
                
                # Load the lambda onto the stack
                self.instructions.append((LOAD_LAMBDA, idx))
            else:
                # For non-lambda values, process normally
                value.accept(self)
        
        self.instructions.append((BUILD_DICT, len(node.pairs)))

    def visit_print(self, node):
        """Emit bytecode for a print statement."""
        node.expression.accept(self)
        self.instructions.append((PRINT,))

    def visit_array_access(self, node):
        """Emit bytecode for accessing an array or dictionary element."""
        # First compile the array expression
        node.array.accept(self)
        
        # Then compile the index expression
        node.index.accept(self)
        
        # This will push the accessed element on the stack
        self.instructions.append((ARRAY_ACCESS,))
        
    def visit_array_assign(self, node):
        """Emit bytecode for assigning a value to an array or dictionary element."""
        # First compile the array expression
        node.array.accept(self)
        
        # Then compile the index expression
        node.index.accept(self)
        
        # Then compile the value to be assigned
        node.value.accept(self)
        
        # This will assign the value to the array at the specified index
        self.instructions.append((ARRAY_ASSIGN,))
    
    def visit_multi_dim_array_access(self, node):
        """Emit bytecode for accessing a multi-dimensional array element."""
        # First compile the base array expression
        node.array.accept(self)
        
        # Then compile each index expression
        for index in node.indices:
            index.accept(self)
        
        # Use the multi-dimensional array access opcode with number of dimensions
        self.instructions.append((MULTI_DIM_ACCESS, len(node.indices)))
    
    def visit_multi_dim_array_assign(self, node):
        """Emit bytecode for assigning a value to a multi-dimensional array element."""
        # First compile the base array expression
        node.array.accept(self)
        
        # Then compile each index expression
        for index in node.indices:
            index.accept(self)
        
        # Then compile the value to be assigned
        node.value.accept(self)
        
        # Use the multi-dimensional array assign opcode with number of dimensions
        self.instructions.append((MULTI_DIM_ASSIGN, len(node.indices)))
    
    def visit_size_of(self, node):
        """Emit bytecode for getting the size of a collection."""
        # Compile the expression whose size we want to get
        node.expression.accept(self)
        
        # Add the GET_SIZE opcode
        self.instructions.append((GET_SIZE,))

    # Optionally, add support for more AST nodes as needed

# Usage example:
# from parser.parser import Parser
# ast = Parser(Lexer(source_code)).parse()
# compiler = BytecodeCompiler()
# instructions, consts = compiler.compile(ast)
# print(instructions)
# print(consts)
